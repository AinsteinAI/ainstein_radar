#!/usr/bin/env python

from wayv_air_api.wayv_air_device_api import Wayv_Air_API

import math
import numpy as np
import time
import signal
import sys
import threading
import smokesignal
from datetime import datetime
import os

from ainstein_radar_msgs.msg import RadarTrackedObjectArray
from ainstein_radar_msgs.msg import RadarTrackedObject
from ainstein_radar_msgs.msg import RadarTargetArray
from ainstein_radar_msgs.msg import RadarTarget
from ainstein_radar_drivers.msg import WayvAirStatus
from geometry_msgs.msg import PoseArray
from geometry_msgs.msg import Pose
from visualization_msgs.msg import Marker
from tf.transformations import quaternion_from_euler
import quaternion
import rospy

# Wayv device communication parameters
MODE_485 = 0
MODE_WIFI = 1
delay_init = 50 # number of target callbacks to pass before sending or reading configurations
delay = delay_init
v_level = 3
if 'linux' in sys.platform:
    SER_PORT_DEFAULT = "/dev/ttyUSB0"
else:
    SER_PORT_DEFAULT = "COM5"
serial_port = rospy.get_param('/wayv_pcl/serial_port', SER_PORT_DEFAULT)
serial_baud = rospy.get_param('/wayv_pcl/serial_baud', 115200)
comm_mode = rospy.get_param('/wayv_pcl/comm_mode', MODE_485)
wifi_ip = rospy.get_param('/wayv_pcl/server_ip', '192.168.4.65')
wifi_port = 8877
target_detail = 0
velocity_enable = 1
point_num_enable = 0
rs485_id = 1
new_comm_config = False
new_param_config = False
new_firmware = False
enbl_pcl = rospy.get_param('/wayv_pcl/enable_pcl', True)
query_config_requested = False
query_config = []
comm_config = []
param_config = []
firmware_up = []
radars_seen = []
logging_mode = rospy.get_param('/wayv_pcl/logging_mode', False)
logging_dir = rospy.get_param('/wayv_pcl/logging_dir', "./Logs/")
logging_format = "%y-%m-%d %H-%M-%S"
logging_files_name = {}
logging_files = {}

def sigint_handler(*args):
    sys.stderr.write('/r')
    # make a list of the radars because the dictionary will change when disconnecting radars
    radar_list = []
    for r in list(wayv_intf.wayv_air.radars.keys()):
        radar_list.append(r)
    for r in radar_list:
        wayv_intf.wayv_air.radar_disconnect(r) # disconnect the radar before quitting
    if logging_mode:
        for file in logging_files.values():
            file.close()
    sys.exit()

def cart2sph(x, y, z):
    r = np.sqrt((x * x) + (y * y) + (z * z))
    if y == 0:
        az = np.pi / 2
    elif y > 0:
        az = np.arctan(x/y)
    else:
        az = np.arctan(x/y) + np.pi

    el = np.arctan(z / np.sqrt( (x * x) + (y * y) ))

    return az, el, r

def sph2cart(az, el, r):
    rcos_theta = r * np.cos(el)
    x = rcos_theta * np.sin(az)
    y = rcos_theta * np.cos(az)
    z = r * np.sin(el)
    return x, y, z

# Function to rotate a set of coordinates [x,y,z] about the various axis via the tilt angles
# Tilt angles are in degrees
def eulerRot(x, y, z, elevTilt, aziTilt):
    # Convert to radians
    elevTilt = np.deg2rad(elevTilt)
    aziTilt = np.deg2rad(aziTilt)

    elevAziRotMatrix = np.matrix([  [  math.cos(aziTilt),  math.cos(elevTilt)*math.sin(aziTilt), math.sin(elevTilt)*math.sin(aziTilt)],
                                    [ -math.sin(aziTilt),  math.cos(elevTilt)*math.cos(aziTilt), math.sin(elevTilt)*math.cos(aziTilt)],
                                    [                  0,                   -math.sin(elevTilt),                   math.cos(elevTilt)],
                                ])

    target =  np.array([[x],[y],[z]])
    rotTarget = elevAziRotMatrix*target
    rotX = rotTarget[0,0]
    rotY = rotTarget[1,0]
    rotZ = rotTarget[2,0]
    return rotX, rotY, rotZ

class WayvROSInterface( object ):
    """
    This class defines a ROS interface to the people counting software running on 
    the Wayv radar sensor in order to publish raw detections as RadarTargetArray
    and tracked detections in Cartesian space as PoseArray.

    """
    
    def __init__( self, frame_id ):
        """ Initialize the ROS interface.

        Initializes the ROS interface for Wayv, setting up publishers for raw and 
        tracked detections. Raw detections are published as RadarTargetArray and
        tracked detections are published as PoseArray because the underlying TI
        people counting firmware tracks in Cartesian space.

        Args:
            frame_id (string): Name of the Wayv sensor's coordinate frame.

        Return:
            (None)

        """

       # Register the ROS interface data callbacks with the sensor
        self.wayv_air = Wayv_Air_API(self.target_callback, self.radar_con_callback, self.pcl_callback,
                                     (v_level >= 3), comm_mode, serial_port, serial_baud,
                                     rs485_id, wifi_ip, target_detail, wifi_port)
    
        print( "Waiting to start communication" )

        if v_level >= 1:
            print("WAYV Air API version:", self.wayv_air.version)
        self.wayv_air.radar_connect()
 
        
        self.pub_point_cloud = rospy.Publisher( '~targets/raw', RadarTargetArray, queue_size=10 )
        self.radar_data_msg = RadarTargetArray()
        self.radar_data_msg.header.frame_id = frame_id

        self.pub_tracked_pose = rospy.Publisher( '~objects/poses', PoseArray, queue_size=10 )
        self.tracked_pose_msg = PoseArray()
        self.tracked_pose_msg.header.frame_id = frame_id

        self.pub_tracked_obj = rospy.Publisher( '~objects/tracked', RadarTrackedObjectArray, queue_size=10 )
        self.tracked_obj_msg = RadarTrackedObjectArray()
        self.tracked_obj_msg.header.frame_id = frame_id

        self.pub_tlv_tracked_pose = rospy.Publisher( '~objects/tlv_poses', PoseArray, queue_size=10 )
        self.tlv_tracked_pose_msg = PoseArray()
        self.tlv_tracked_pose_msg.header.frame_id = frame_id


        self.pub_tlv_tracked_obj = rospy.Publisher( '~objects/tlv_tracked', RadarTrackedObjectArray, queue_size=10 )
        self.tlv_tracked_obj_msg = RadarTrackedObjectArray()
        self.tlv_tracked_obj_msg.header.frame_id = frame_id

        self.pub_status = rospy.Publisher( '~status', WayvAirStatus, queue_size=10 )
        self.status_msg = WayvAirStatus()
        self.status_msg.header.frame_id = frame_id

        self.pub_boundary_box = rospy.Publisher( '~boundary_box', Marker, queue_size=10 )
        self.boundary_box_msg = Marker()
        self.boundary_box_msg.header.frame_id = frame_id
        self.boundary_box_msg.type = 10
        self.boundary_box_msg.action = 0
        self.boundary_box_msg.color.r = 0
        self.boundary_box_msg.color.g = 0
        self.boundary_box_msg.color.b = .5
        self.boundary_box_msg.color.a = 1
        self.boundary_box_msg.mesh_resource = "package://ainstein_radar_drivers/meshes/boundaryBox.stl"

        self.pub_wayv_marker = rospy.Publisher( '~model', Marker, queue_size=10 )
        self.wave_marker_msg = Marker()
        self.wave_marker_msg.header.frame_id = frame_id
        self.wave_marker_msg.type = 10
        self.wave_marker_msg.action = 0
        self.wave_marker_msg.pose.position.x = 0
        self.wave_marker_msg.pose.position.y = 0
        self.wayv_model_scale = 3  # Modify this value to change scale of WA model, 1 = Actual size. Set to 3x for better visibility
        self.wave_marker_msg.scale.x = (1/1000)*self.wayv_model_scale
        self.wave_marker_msg.scale.y = (1/1000)*self.wayv_model_scale
        self.wave_marker_msg.scale.z = (1/1000)*self.wayv_model_scale
        self.wave_marker_msg.color.r = 1
        self.wave_marker_msg.color.g = 1
        self.wave_marker_msg.color.b = 1
        self.wave_marker_msg.color.a = 1
        self.wave_marker_msg.mesh_resource = "package://ainstein_radar_drivers/meshes/wayv_air.stl"

        
    def radar_con_callback(self, id):
        global new_firmware, query_config, comm_config, param_config, firmware_up, logging_mode, logging_files, logging_files_name, logging_format, logging_dir
        if id not in radars_seen:
            radars_seen.append(id)
            if new_comm_config:
                comm_config.append(id)  # tell the supervisor to update this radar's comm. config
            if new_param_config:
                param_config.append(id)  # tell the supervisor to update this radar's radar parameters
            if new_firmware:
                firmware_up.append(id)  # tell the supervisor to update this radar's firmware
            if logging_mode:
                logging_files_name[id] = logging_dir + id + " - " +  datetime.now().strftime(logging_format) + ".log"
                if not os.path.exists(logging_dir):
                    os.makedirs(logging_dir)
                logging_files[id] = open(logging_files_name[id], 'wt', encoding="utf-8")
        query_config.append(id)  # tell the supervisor to query the config for this radar

        
    def target_to_pose(self, px, py, pz, vx, vy, vz):
        """
        Converts a tracked object to Pose representation.

        Utility function for converting a tracked object received from the radar 
        having position and velocity information to a Pose message. The velocity
        is used to define the orientation.

        Args:
            px (Float): Target x position.
            py (Float): Target y position.
            pz (Float): Target z position.
            vx (Float): Target x velocity.
            vy (Float): Target y velocity.
            vz (Float): Target z velocity.

        Returns:
            (Pose): Pose representing the target.

        """
        pose = Pose()
        pose.position.x = py
        pose.position.y = -px
        pose.position.z = pz

        # Compute target pose, assuming velocity is in +x direction
        vel = np.array( [vy, -vx, vz] ).transpose()

        # If velocity is near zero, keep identity orientation
        rot_mat = np.identity( 3 )
        if( np.linalg.norm( vel ) > 0.001 ):
            rot_mat[:,0] = vel / np.linalg.norm( vel )
            rot_mat[:,1] = np.cross( np.array( [0.0, 0.0, 1.0] ),
                                     rot_mat[:,0] )
            rot_mat[:,2] = np.cross( rot_mat[:,0], rot_mat[:,1] )

        # Convert from rotation matrix to quaternion to fill ROS pose
        quat = quaternion.from_rotation_matrix( rot_mat )
        pose.orientation.w = quat.w
        pose.orientation.x = quat.x
        pose.orientation.y = quat.y
        pose.orientation.z = quat.z

        return pose
    

    def target_to_obj(self, px, py, pz, vx, vy, vz):
        """
        Converts a tracked object to RadarTrackedObject representation.

        Utility function for converting a tracked object received from the radar 
        having position and velocity information to a Tracked Object message.

        Args:
            px (Float): Target x position.
            py (Float): Target y position.
            pz (Float): Target z position.
            vx (Float): Target x velocity.
            vy (Float): Target y velocity.
            vz (Float): Target z velocity.

        Returns:
            (obj_msg): Message containing tracked object information.

        """
        obj_msg = RadarTrackedObject()

        obj_msg.pose.position.x = py
        obj_msg.pose.position.y = -px
        obj_msg.pose.position.z = pz

        obj_msg.velocity.linear.x = vy
        obj_msg.velocity.linear.x = -vx
        obj_msg.velocity.linear.x = vz

        obj_msg.box.pose.position.x = py
        obj_msg.box.pose.position.x = -px
        obj_msg.box.pose.position.x = pz

        # Compute target pose, assuming velocity is in +x direction
        vel = np.array( [vy, -vx, vz] ).transpose()

        # If velocity is near zero, keep identity orientation
        rot_mat = np.identity( 3 )
        if( np.linalg.norm( vel ) > 0.001 ):
            rot_mat[:,0] = vel / np.linalg.norm( vel )
            rot_mat[:,1] = np.cross( np.array( [0.0, 0.0, 1.0] ),
                                     rot_mat[:,0] )
            rot_mat[:,2] = np.cross( rot_mat[:,0], rot_mat[:,1] )

        # Convert from rotation matrix to quaternion to fill ROS pose
        quat = quaternion.from_rotation_matrix( rot_mat )
        
        obj_msg.pose.orientation.w = quat.w
        obj_msg.pose.orientation.x = quat.x
        obj_msg.pose.orientation.y = quat.y
        obj_msg.pose.orientation.z = quat.z

        obj_msg.box.pose.orientation.w = quat.w
        obj_msg.box.pose.orientation.x = quat.x
        obj_msg.box.pose.orientation.y = quat.y
        obj_msg.box.pose.orientation.z = quat.z

        return obj_msg



    # def target_to_world_orientation(self, target: RadarTarget, radar_cfg: list) -> RadarTarget:
    #     """Takes a radar target type in spherical format relative to the sensor and returns
    #        spherical format using world coordinates.

    #     Args:
    #         target (RadarTarget): Target in spherical coordinates relative to sensor
    #         radar_cfg (list): Radar Config cmds list as provided by the WAYV API

    #     Returns:
    #         RadarTarget: Updated RadarTarget
    #     """
    #     new_target = RadarTarget()
    #     new_target.snr = target.snr
    #     new_target.speed = target.speed

    #     # Convert to cartesian
    #     sensor_x = target.range * math.cos(target.elevation) * math.sin(target.azimuth)
    #     sensor_y = target.range * math.cos(target.elevation) * math.cos(target.azimuth)
    #     sensor_z = target.range * math.sin(target.elevation)
        

    #     # Read Tilt values from Radar configuration
    #     for item in radar_cfg:
    #         args = item.split()
    #         if args[0] == 'sensorPosition':
    #             sensor_height = float(args[1])
    #             azi_tilt = float(args[2])
    #             elev_tilt = float(args[3])
    #             cos_elev_tilt = math.cos(math.radians(elev_tilt))
    #             sin_elev_tilt = math.sin(math.radians(elev_tilt))

    #     # Convert cartesian from sensor to world cartesian
    #     world_x = sensor_x
    #     world_y = (sensor_y * cos_elev_tilt) + (sensor_z * sin_elev_tilt)
    #     world_z = -(sensor_y * sin_elev_tilt) + (sensor_z * cos_elev_tilt) + sensor_height

    #     new_target.range = math.sqrt( (world_x ** 2) + (world_y ** 2) + (world_z ** 2) )
    #     new_target.azimuth = math.atan( world_x / world_y )
    #     new_target.elevation = math.atan( world_z / math.sqrt( (world_x ** 2) + (world_y ** 2) ))

    #     return new_target


    def target_callback(self, id):
        """ Callback to process data from the Wayv and publish ROS messages.

        Receives point cloud (raw detection) and tracked object data from the
        firmware, packs the data into ROS messages and publishes. Note that the 
        orientation of the tracked object pose is derived from its velocity,
        under the assumption that objects always move in the forward direction.

        Also note that the full (3d) velocity is available for all tracked objects
        but is unused in this driver because it would require custom VectorArray 
        message types. To be added in the future.

        Args:
            data (array of dict arrays): Data from the Wayv, organized by TLV.

        Returns:
            (None)

        """

        # Clear the output ROS message array
        self.tracked_pose_msg.poses = []
        self.tracked_obj_msg.objects = []

        # Receive and pack Wayv tracked object info into ROS message
        for v in self.wayv_air.radars.values():
            if v.targets_recvd:  # Only print targets from devices that have new targets; could also tell this from id passed to the callback
                v.targets_recvd = False
                if logging_mode:
                    time_str = "%Y-%m-%d %H:%M:%S.%f"
                    ts_count = len(v.targets)
                    sample_time = datetime.now().strftime(time_str)
                    logging_files[v.id].write(f"targets: {v.id}\t{sample_time}\t{ts_count}\n")

                if target_detail == 1:            ## call debug mode format for Wayv Air
                    if velocity_enable == 1:
                        if point_num_enable == 1:
                            for tar in v.targets:
                                self.tracked_pose_msg.poses.append(
                                    self.target_to_pose(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                                self.tracked_obj_msg.objects.append(
                                    self.target_to_obj(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                                if logging_mode:
                                    logging_files[v.id].write('%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\n' %
                                                            (tar.tid, tar.x, tar.y, tar.z, tar.vel_x,
                                                            tar.vel_y, tar.vel_z, tar.a_x, tar.a_y, tar.a_z,
                                                            tar.cp_count))
                        else:  # velocity only, not point number
                            for tar in v.targets:
                                self.tracked_pose_msg.poses.append(
                                    self.target_to_pose(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                                self.tracked_obj_msg.objects.append(
                                    self.target_to_obj(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                                if logging_mode:
                                    logging_files[v.id].write('%d\t%f\t%f\t%f\t%f\t%f\t%f\n' % (tar.tid, tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                    elif point_num_enable == 1:  # point number, not velocity
                        for tar in v.targets:
                            self.tracked_pose_msg.poses.append(
                                self.target_to_pose(tar.x, tar.y, tar.z, 0.0, 0.0, 0.0))
                            self.tracked_obj_msg.objects.append(
                                self.target_to_obj(tar.x, tar.y, tar.z, 0.0, 0.0, 0.0))
                            if logging_mode:
                                logging_files[v.id].write('%d\t%f\t%f\t%f\t%f\n' % (tar.tid, tar.x, tar.y, tar.z, tar.cp_count))
                elif target_detail == 0:          ## call normal mode format for Wayv Air
                    for tar in v.targets:
                        self.tracked_pose_msg.poses.append(
                            self.target_to_pose(tar.x, tar.y, tar.z, 0.0, 0.0, 0.0))
                        self.tracked_obj_msg.objects.append(
                            self.target_to_obj(tar.x, tar.y, tar.z, 0.0, 0.0, 0.0))
                        if logging_mode:
                            logging_files[v.id].write('%d\t%f\t%f\t%f\n' % (tar.tid, tar.x, tar.y, tar.z))
                else:                               ## default in  debug mode format for Wayv Air
                    for tar in v.targets:
                        self.tracked_pose_msg.poses.append(
                            self.target_to_pose(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                        self.tracked_obj_msg.objects.append(
                            self.target_to_obj(tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))
                        if logging_mode:
                            logging_files[v.id].write('%d\t%f\t%f\t%f\t%f\t%f\t%f\n' % (tar.tid, tar.x, tar.y, tar.z, tar.vel_x, tar.vel_y, tar.vel_z))

            # Timestamp and publish tracked object poses
            self.tracked_pose_msg.header.stamp = rospy.Time.now()
            self.pub_tracked_pose.publish( self.tracked_pose_msg )
            self.pub_tracked_obj.publish( self.tracked_obj_msg )

            # May also publish the board status, to be added with new message
            if v_level >= 2:
                self.status_msg.board_temp = v.board_temp
                self.status_msg.tx_temps = []
                for temp in v.tx_temps:
                    self.status_msg.tx_temps.append(temp)
                self.status_msg.pm_temp = v.pm_temp
                self.status_msg.voltage = v.voltage
                self.status_msg.power = v.power
                self.status_msg.header.stamp = rospy.Time.now()
                
                self.pub_status.publish( self.status_msg )

        
    def pcl_callback(self, id):
        """ Callback to process data from the Wayv and publish ROS messages.

        Receives point cloud (raw detection) and tracked object data from the
        firmware, packs the data into ROS messages and publishes. Note that the 
        orientation of the tracked object pose is derived from its velocity,
        under the assumption that objects always move in the forward direction.

        Also note that the full (3d) velocity is available for all tracked objects
        but is unused in this driver because it would require custom VectorArray 
        message types. To be added in the future.

        Args:
            data (array of dict arrays): Data from the Wayv, organized by TLV.

        Returns:
            (None)

        """
        
        # Clear the output ROS message arrays
        self.radar_data_msg.targets = []
        self.tlv_tracked_pose_msg.poses = []
        self.tlv_tracked_obj_msg.objects = []

        for item in self.wayv_air.radars[id].radar_config.cmds:
            args = item.split()
            if args[0] == 'sensorPosition':
                sensor_height = float(args[1])
                azi_tilt = float(args[2])
                elev_tilt = float(args[3])

        # Receive and pack Wayv point cloud detections into ROS message
        num_points = len(self.wayv_air.radars[id].points)
        if logging_mode:
            time_str = "%Y-%m-%d %H:%M:%S.%f"
            sample_time = datetime.now().strftime(time_str)
            logging_files[id].write(f"pcl: {sample_time}\t{num_points}\n")
        i = 0
        for p in self.wayv_air.radars[id].points:
            target = RadarTarget()
            target.target_id = i
            target.range = p.range
            target.azimuth = p.azimuth
            target.elevation = p.elevation
            target.speed = p.doppler
            target.snr = p.snr

            if logging_mode:
                logging_files[id].write(f"{target.range}\t"
                                        f"{target.azimuth}\t"
                                        f"{target.elevation}\t"
                                        f"{target.speed}\t"
                                        f"{target.snr}\n")

            # Translate point orientation to be relative to the mounting position.
            sensor_x, sensor_y, sensor_z = sph2cart(target.azimuth, target.elevation, target.range)
            world_x, world_y, world_z = eulerRot (sensor_x, sensor_y, sensor_z, elev_tilt, azi_tilt)
            world_z += sensor_height
            target.azimuth, target.elevation, target.range = cart2sph(world_x, world_y, world_z)

            target.azimuth = -1.0 * math.degrees( target.azimuth )
            # target.azimuth = math.degrees( target.azimuth )
            target.elevation = math.degrees( target.elevation )
            self.radar_data_msg.targets.append( target )
            i = i + 1

            print(f"range: {target.range:.2f}, "\
                  f"azimuth: {target.azimuth:.2f}, "\
                  f"elevation: {target.elevation:.2f}, "\
                  f"speed: {target.speed:.2f}, "\
                  f"snr: {target.snr:.2f}, ")

        # num_tlv_targets = len(self.wayv_air.radars[id].tlv_targets)
        # print(f"Tracked Target Packet: {num_tlv_targets} targets")
        num_targets = len(self.wayv_air.radars[id].tlv_targets)
        if logging_mode:
            time_str = "%Y-%m-%d %H:%M:%S.%f"
            sample_time = datetime.now().strftime(time_str)
            logging_files[id].write(f"pcl: {sample_time}\t{num_targets}\n")

        for target in self.wayv_air.radars[id].tlv_targets:
            if logging_mode:
                logging_files[id].write(f"{target.tid}\t"
                                    f"{target.x}\t"
                                    f"{target.y:}\t"
                                    f"{target.z:}\t"
                                    f"{target.vel_x}\t"
                                    f"{target.vel_y}\t"
                                    f"{target.vel_z}\t"
                                    f"{target.acc_x}\t"
                                    f"{target.acc_y}\t"
                                    f"{target.acc_z}\t"
                                    # "{target.ec_matrix}\t"
                                    f"{target.gating_gain}\t"
                                    f"{target.confidence_level}\n")

            # Translate targets orientation to be relative to the mounting position.
            target.x, target.y, target.z = eulerRot (target.x, target.y, target.z, 90, 0)
            target.z += sensor_height
            self.tlv_tracked_pose_msg.poses.append(
                self.target_to_pose(target.x, target.y, target.z, 0.0, 0.0, 0.0))
            self.tlv_tracked_obj_msg.objects.append(
                self.target_to_obj(target.x, target.y, target.z, 0.0, 0.0, 0.0))

            print(f"tar id: {target.tid}, "\
                    f"x: {target.x:.2f}, "\
                    f"y: {target.y:.2f}, "\
                    f"z: {target.z:.2f}, "\
                    f"vel_x: {target.vel_x:.2f}, "\
                    f"vel_y: {target.vel_y:.2f}, "\
                    f"vel_z: {target.vel_z:.2f}, "\
                    f"acc_x: {target.acc_x:.2f}, "\
                    f"acc_y: {target.acc_y:.2f}, "\
                    f"acc_z: {target.acc_z:.2f}, "\
                #   f"ec_matrix: {target.ec_matrix:.2f}, "\
                    f"gating_gain: {target.gating_gain:.2f}, "\
                    f"confidence_level: {target.confidence_level:.2f}")

        # Timestamp and publish radar point cloud
        self.radar_data_msg.header.stamp = rospy.Time.now()
        self.pub_point_cloud.publish( self.radar_data_msg )

        # Timestamp and publish tracked object poses
        self.tlv_tracked_pose_msg.header.stamp = rospy.Time.now()
        self.pub_tlv_tracked_pose.publish( self.tlv_tracked_pose_msg )
        self.pub_tlv_tracked_obj.publish( self.tlv_tracked_obj_msg )

        
    def supervisor(self):
        # This function handles less time-sensitive operations like updating configurations
        # and firmware. It also provides a mechanism for the Python interpreter to run so the
        # signint handler can exit the program properly
        global query_config, comm_config, param_config, new_firmware, query_config_requested, enbl_pcl

        for v in self.wayv_air.radars.values():
            # print progress updates
            if v.progress > 0:
                print(v.ser_no, "update progress:", v.progress, "%")
            if v.progress >= 100:
                v.progress = -1  # use negative numbers to indicate acknowledged completion

            # check for new config messages and acknowledge them
            if v.comm_config_recvd and v.radar_config_recvd:
                # Wait for query to be received
                if query_config_requested:
                    query_config_requested = False
                    if v_level >= 1:
                        # print firmware version
                        print("Device: ", v.ser_no, "Firmware Version:", v.fw_version)
                        print("Device: ", v.ser_no, "SBL Version: ", v.sbl_version)
                        print("Present Comm. Config:")
                        for item in v.comm_config.__dict__.items():
                            print(item)
                        print("")
                        print("Present Radar Config: (",v.radar_config.cmd_count,"lines )")
                        for item in v.radar_config.cmds:
                            print(item)
                            args = item.split()
                            if args[0] == 'boundaryBox':
                                bbox = threading.Thread(target=wayv_intf.pub_boundary_box_msg, args=[args])
                                bbox.start()
                            if args[0] == 'sensorPosition':
                                wayv_model = threading.Thread(target=wayv_intf.pub_wayv_marker_msg, args=[args])
                                wayv_model.start()
                        print("")

                    # Disable PCL mode if already in PCL mode
                    if v.comm_config.sys_mode != 0 and enbl_pcl is False:
                        self.wayv_air.enable_pcl(v.id, False)

                    # Enable PCL mode if requested
                    if enbl_pcl:
                        self.wayv_air.enable_pcl(v.id, True) # Enable Point Cloud mode on this radar

        if len(query_config) > 0:
            id = query_config.pop(0)
            self.wayv_air.query_config(id)  # the API only support querying one radar at a time
            query_config_requested = True

        elif len(comm_config) > 0:
            id = comm_config.pop(0)
            self.wayv_air.modify_comm_config(id, comm_file)  # only the first radar in this example
            if id not in query_config:
                query_config.append(id)

        elif len(param_config) > 0:
            id = param_config.pop(0)
            self.wayv_air.modify_param_config(id, param_file)  # only the first radar in this example
            if id not in query_config:
                query_config.append(id)
                
        elif len(firmware_up) > 0:
            id = firmware_up.pop(0)
            if id not in query_config:
                query_config.append(id)
            self.wayv_air.update_firmware(id, fw_path)


    def pub_boundary_box_msg(self, boundaryBox):
        """
        This function handles publishing a Marker topic 
        to visually represent the boundaryBox config value
        """
        # Get boundary box values from config
        x_min = float(boundaryBox[1])
        x_max = float(boundaryBox[2])
        y_min = float(boundaryBox[3])
        y_max = float(boundaryBox[4])
        z_min = float(boundaryBox[5])
        z_max = float(boundaryBox[6])
        
        # Set location, size and orientation of the boundary box
        self.boundary_box_msg.scale.y = (x_max - x_min)
        self.boundary_box_msg.scale.x = (y_max - y_min)
        self.boundary_box_msg.scale.z = (z_max - z_min)

        self.boundary_box_msg.pose.position.y = -(x_max + x_min)/2
        self.boundary_box_msg.pose.position.x = (y_max + y_min)/2
        self.boundary_box_msg.pose.position.z = (z_max + z_min)/2

        quaternion_list = quaternion_from_euler(0, 0, 0)
        self.boundary_box_msg.pose.orientation.x = quaternion_list[0]
        self.boundary_box_msg.pose.orientation.y = quaternion_list[1]
        self.boundary_box_msg.pose.orientation.z = quaternion_list[2]
        self.boundary_box_msg.pose.orientation.w = quaternion_list[3]

        # Publish at a specified rate
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():     
            # Timestamp and publish marker message
            self.boundary_box_msg.header.stamp = rospy.Time.now()
            self.pub_boundary_box.publish(self.boundary_box_msg)
            rate.sleep()
    

    def pub_wayv_marker_msg(self, sensorPosition):
        """
        This function handles publishing a Marker topic 
        to visually represent the wayv air sensor location
        """
        # Parse sensorPosition args
        sensor_height = float(sensorPosition[1])
        azi_tilt = float(sensorPosition[2])
        elev_tilt = float(sensorPosition[3])

        # Set position and orientation of wayv air model
        self.wave_marker_msg.pose.position.z = sensor_height

        # Couldn't remember how to properly use quaternion.from_rotation_matrix() so used a different function that I am more comfortable with
        quaternion_list = quaternion_from_euler(math.radians(90+elev_tilt), 0, math.radians(90)+azi_tilt)  # Did not verify if azimuth tilt was implemented correctly
        self.wave_marker_msg.pose.orientation.x = quaternion_list[0]
        self.wave_marker_msg.pose.orientation.y = quaternion_list[1]
        self.wave_marker_msg.pose.orientation.z = quaternion_list[2]
        self.wave_marker_msg.pose.orientation.w = quaternion_list[3]

        # Publish at a specified rate
        rate = rospy.Rate(1)  # 1 Hz
        while not rospy.is_shutdown():
            # Timestamp and publish marker message
            self.wave_marker_msg.header.stamp = rospy.Time.now()
            self.pub_wayv_marker.publish(self.wave_marker_msg)
            rate.sleep()


    
if __name__ == "__main__":
    try:
        rospy.init_node( 'wayv_node' )
        frame_id = rospy.get_param( '~frame_id', 'map' )
        data_port = rospy.get_param( '~data_port', '/dev/ttyUSB0' )

        # Set up an event loop to make the python interpreter run periodically
        # so that ctrl+c will disconnect the radar and kill the program
        signal.signal(signal.SIGINT, sigint_handler)

        # Create the ROS interface 
        wayv_intf = WayvROSInterface( frame_id )

        # The QApplication must be started before anything can be sent to, or received from, the Wayv Air
        timer = threading.Timer(2, wayv_intf.supervisor)
        timer.start()

        time.sleep(2)  # delay long enough for the radar to connect over WiFi

        #Initialize signal watcher for config 
        smokesignal.on('config_ready', wayv_intf.supervisor)

        rospy.spin()
        
    except rospy.ROSInterruptException:
        pass
